---
---

:skip-front-matter:

= Python Interface
:toc:
[[cha:python-interface]] (((Python Interface)))


== The linuxcnc Python module

NB.

Whilst most of Machinekit has been renamed from Linuxcnc it was forked from,
this *"linuxcnc"* library module remains unchanged, because to rename would
currently cause too many legacy programs to cease working.

User interfaces control Machinekit activity by sending
NML messages to the Machinekit task controller, and monitor results by
observing the Machinekit status structure, as well as the error reporting channel.

Programmatic access to NML is through a C++ API; however, the most
important parts of the NML interface to Machinekit are also available to
Python programs through the `linuxcnc` module.

Beyond the NML interface to the command, status and error channels,
the `linuxcnc` module also contains:

- support for reading values from ini files
- support for position logging  (???)


== Usage Patterns for the Machinekit NML interface

The general pattern for `linuxcnc` usage is roughly like this:

- import the `linuxcnc` module
- establish connections to the command, status and error NML channels as needed
- poll the status channel, either periodically or as needed
- before sending a command, determine from status whether it is in
 fact OK to do so (for instance, there is no point in sending a 'Run'
 command if task is in the ESTOP state, or the interpreter is not
 idle)
- send the command by using one of  the `linuxcnc`  command channel methods


To retrieve messages from the error channel, poll the error channel
periodically, and process any messages retrieved.

- poll the status channel, either periodically or as needed
- print any error message FIXME: explore the exception code

`linuxcnc` also defines the `error` Python exception type to support error reporting.

== Reading Machinekit status

Here is a Python fragment to explore the contents of the
`linuxcnc.stat` object which contains some 8ÃŸ0+ values (run while
machinekit is running for typical values):

[source,python]
----
import sys
import linuxcnc
try:
    s = linuxcnc.stat() # create a connection to the status channel
    s.poll() # get current values 
except linuxcnc.error, detail:
    print "error", detail
    sys.exit(1)
for x in dir(s):
    if not x.startswith('_'):
        print x, getattr(s,x)
----

Machinekit uses the default compiled-in path to the NML configuration
file unless overridden, see <<sec:Python-reading-ini-values,Reading
ini file values>> for an example.


=== linuxcnc.stat attributes

*acceleration* :: _returns float_ -
default acceleration, reflects the ini entry [TRAJ] DEFAULT_ACCELERATION.

*active_queue*:: _returns int_ -
number of motions blending.

*actual_position*:: _returns tuple of floats_ -
current trajectory position, (x y z a b c u v w) in machine units.

*adaptive_feed_enabled*:: _returns True/False_ -
status of adaptive feedrate override (0/1).

*ain*:: _returns tuple of floats_ -
current value of the analog input pins.

*angular_units*:: _returns string_ -
reflects [TRAJ] ANGULAR_UNITS ini value.

*aout*:: _returns tuple of floats_ -
current value of the analog output pins.

*axes*:: _returns string_ -
reflects [TRAJ] AXES ini value.

*axis*:: _returns tuple of dicts_ -
reflecting current axis values. See
<<sec:The-Axis-dictionary,The axis dictionary>>.

*axis_mask*:: _returns integer_ -
mask of axis available as defined by [TRAJ] COORDINATES in the ini
file. Returns the sum of the axes X=1, Y=2, Z=4, A=8, B=16, C=32, U=64,
V=128, W=256.

*block_delete*:: _returns integer_ -
block delete currently on/off.

*command*:: _returns string_ -
currently executing command.

*current_line*:: _returns integer_ -
currently executing line, int.

*current_vel*:: _returns float_ -
current velocity in Cartesian space.

*cycle_time*:: _returns string_ -
reflects [TRAJ] CYCLE_TIME ini value (FIXME is this right?).

*debug*:: _returns integer_ -
debug flag.

*delay_left*:: _returns float_ -
remaining time on dwell (G4) command, seconds.

*din*:: _returns tuple of integers_ -
current value of the digital input pins.

*distance_to_go*:: _returns float_ -
remaining distance of current move, as reported by trajectory planner, in Cartesian space.

*dout*:: _returns tuple of integers_ -
current value of the digital output pins.

*dtg*:: _returns tuple of 9 floats_ -
remaining distance of current move, as reported by trajectory planner.

*echo_serial_number*:: _returns integer_ -
The serial number of the last completed command sent by a UI
to task. All commands carry a serial number. Once the command
has been executed, its serial number is reflected in
`echo_serial_number`.

*enabled*:: _returns integer_ -
trajectory planner enabled flag.

*estop*:: _returns integer_ -
estop flag.

*exec_state*:: _returns integer_ -
task execution state. One of EXEC_ERROR, EXEC_DONE,
EXEC_WAITING_FOR_MOTION, EXEC_WAITING_FOR_MOTION_QUEUE,
EXEC_WAITING_FOR_PAUSE,EXEC_WAITING_FOR_MOTION_AND_IO,
EXEC_WAITING_FOR_DELAY, EXEC_WAITING_FOR_SYSTEM_CMD.

*feed_hold_enabled*:: _returns integer_ -
enable flag for feed hold.

*feed_override_enabled*:: _returns integer_ -
enable flag for feed override.

*feedrate*:: _returns float_ -
current feedrate override.

*file*:: _returns string_ -
currently executing gcode file.

*flood*:: _returns integer_ -
flood enabled.

*g5x_index*:: _returns string_ -
currently active coordinate system, G54=0, G55=1 etc.

*g5x_offset*:: _returns tuple of floats_ -
offset of the currently active coordinate system.

*g92_offset*:: _returns tuple of floats_ -
pose of the current g92 offset.

*gcodes*:: _returns tuple of 16 integers_ -
currently active G-codes.

*homed*:: _returns integer_ -
flag. 1 if homed.

*id*:: _returns integer_ -
currently executing motion id.

*inpos*:: _returns integer_ -
machine-in-position flag.

*input_timeout*:: _returns integer_ -
flag for M66 timer in progress.

*interp_state*:: _returns integer_ -
current state of RS274NGC interpreter. One of
INTERP_IDLE, INTERP_READING, INTERP_PAUSED, INTERP_WAITING.

*interpreter_errcode*:: _returns integer_ -
current RS274NGC interpreter return code. One of
INTERP_OK, INTERP_EXIT, INTERP_EXECUTE_FINISH, INTERP_ENDFILE,
INTERP_FILE_NOT_OPEN, INTERP_ERROR. 
see src/emc/nml_intf/interp_return.hh

*joint_actual_position*:: _returns tuple of floats_ -
actual joint positions.

*joint_position*:: _returns tuple of floats_ -
Desired joint positions.

*kinematics_type*:: _returns integer_ -
identity=1, serial=2, parallel=3, custom=4 .

*limit*:: _returns tuple of integers_ -
axis limit masks. minHardLimit=1,
maxHardLimit=2, minSoftLimit=4, maxSoftLimit=8.

*linear_units*:: _returns string_ -
reflects [TRAJ]LINEAR_UNITS ini value.

*lube*:: _returns integer_ -
'lube on' flag.

*lube_level*:: _returns integer_ -
reflects 'iocontrol.0.lube_level'.

*max_acceleration*:: _returns float_ -
maximum  acceleration. reflects [TRAJ] MAX_ACCELERATION.

*max_velocity*:: _returns float_ -
maximum  velocity. reflects [TRAJ] MAX_VELOCITY.

*mcodes*:: _returns tuple of 10 integers_ -
currently active M-codes.

*mist*:: _returns integer_ -
'mist on' flag.

*motion_line*:: _returns integer_ -
source line number motion is currently executing. Relation
to `id` unclear.

*motion_mode*:: _returns integer_ -
motion mode.

*motion_type*:: _returns integer_ -
trajectory planner mode. One of TRAJ_MODE_COORD,
TRAJ_MODE_FREE, TRAJ_MODE_TELEOP.

*optional_stop*:: _returns integer_ -
option stop flag.

*paused*:: _returns integer_ -
`motion paused` flag.

*pocket_prepped*:: _returns integer_ -
A Tx command completed, and this pocket is prepared. -1 if no
prepared pocket.

*poll()*:: -
method to update current status attributes.

*position*:: _returns tuple of floats_ -
trajectory position.

*probe_tripped*:: _returns integer_ -
flag, true if probe has tripped (latch)

*probe_val*:: _returns integer_ -
reflects value of the `motion.probe-input` pin.

*probed_position*:: _returns tuple of floats_ -
position where probe tripped.

*probing*:: _returns integer_ -
flag, 1 if a probe operation is in progress.

*program_units*:: _returns integer_ -
one of CANON_UNITS_INCHES=1, CANON_UNITS_MM=2, CANON_UNITS_CM=3

*queue*:: _returns integer_ -
current size of the trajectory planner queue.

*queue_full*:: _returns integer_ -
the trajectory planner queue is full.

*read_line*:: _returns integer_ -
line the RS274NGC interpreter is currently reading.

*rotation_xy*:: _returns float_ -
current XY rotation angle around Z axis.

*settings*:: _returns tuple of 3 floats_ -
current interpreter settings. settings[0] =
sequence number, settings[1] = feed rate, settings[2] = speed.

*spindle_brake*:: _returns integer_ -
value of the spindle brake flag.

*spindle_direction*:: _returns integer_ -
rotational direction of the spindle. forward=1, reverse=-1.

*spindle_enabled*:: _returns integer_ -
value of the spindle enabled flag.

*spindle_increasing*:: _returns integer_ -
unclear.

*spindle_override_enabled*:: _returns integer_ -
value of the spindle override enabled flag.

*spindle_speed*:: _returns float_ -
spindle speed value, rpm, > 0: clockwise, < 0:
counterclockwise.

*spindlerate*:: _returns float_ -
spindle speed override scale.

*state*:: _returns integer_ -
current command execution status. One of RCS_DONE,
RCS_EXEC, RCS_ERROR.

*task_mode*:: _returns integer_ -
current task mode. one of MODE_MDI, MODE_AUTO,
MODE_MANUAL.

*task_paused*:: _returns integer_ -
task paused flag.

*task_state*:: _returns integer_ -
current task state. one of STATE_ESTOP,
STATE_ESTOP_RESET, STATE_ON, STATE_OFF.

*tool_in_spindle*:: _returns integer_ -
current tool number.

*tool_offset*:: _returns tuple of floats_ -
offset values of the current tool.

*tool_table*:: _returns tuple of tool_results_ -
list of tool entries. Each entry is a sequence of the following fields:
id, xoffset, yoffset, zoffset, aoffset, boffset, coffset, uoffset, voffset,
woffset, diameter, frontangle, backangle, orientation. The id and orientation
are integers and the rest are floats.

*velocity*:: _returns float_ -
default  velocity. reflects [TRAJ] DEFAULT_VELOCITY.

=== The `axis` dictionary [[sec:The-Axis-dictionary]]

The axis configuration and status values are available through a list
of per-axis dictionaries. Here's an example how to access an attribute
of a particular axis:

[source,python]
----
import linuxcnc
s = linuxcnc.stat() 
s.poll() 
print 'Axis 1 homed: ', s.axis[1]['homed']
----

For each axis, the following dictionary keys are available:

*axisType*:: _returns integer_ -
type of axis configuration parameter, reflects
[AXIS_x]TYPE. LINEAR=1, ANGULAR=2. See <<sub:AXIS-section, Axis
ini configuration>> for details.

*backlash*:: _returns float_ -
Backlash in machine units. configuration parameter, reflects [AXIS_x]BACKLASH.

*enabled*:: _returns integer_ -
non-zero means enabled.

*fault*:: _returns integer_ -
non-zero means axis amp fault.

*ferror_current*:: _returns float_ -
current following error.

*ferror_highmark*:: _returns float_ -
magnitude of max following error.

*homed*:: _returns integer_ -
non-zero means has been homed.

*homing*:: _returns integer_ -
non-zero means homing in progress.

*inpos*:: _returns integer_ -
non-zero means in position.

*input*:: _returns float_ -
current input position.

*max_ferror*:: _returns float_ -
maximum following error. configuration
parameter, reflects [AXIS_x]FERROR.

*max_hard_limit*:: _returns integer_ -
non-zero means max hard limit exceeded.

*max_position_limit*:: _returns float_ -
maximum limit (soft limit) for axis motion, in machine units.configuration
parameter, reflects [AXIS_x]MAX_LIMIT.

*max_soft_limit*::
non-zero means `max_position_limit` was exceeded, int

*min_ferror*:: _returns float_ -
configuration parameter, reflects [AXIS_x]MIN_FERROR.

*min_hard_limit*:: _returns integer_ -
non-zero means min hard limit exceeded.

*min_position_limit*:: _returns float_ -
minimum limit (soft limit) for axis motion, in machine units.configuration
parameter, reflects [AXIS_x]MIN_LIMIT.

*min_soft_limit*:: _returns integer_ -
non-zero means `min_position_limit` was exceeded.

*output*:: _returns float_ -
commanded output position.

*override_limits*:: _returns integer_ -
non-zero means limits are overridden.

*units*:: _returns float_ -
units per mm, deg for linear, angular

*velocity*:: _returns float_ -
current velocity.

==  Preparing to send  commands 

Some commands can always be sent, regardless of mode and state; for
instance, the `linuxcnc.command.abort()` method can always be called. 

Other commands may be sent only in appropriate state, and those tests
can be a bit tricky. For instance, an MDI command can be sent only if:

- ESTOP has not been triggered, and
- the machine is turned on and
- the axes are homed and
- the interpreter is not running and
- the mode is set to `MDI mode`

so an appropriate test before sending an MDI command through
`linuxcnc.command.mdi()` could be:

[source,python]
---------------------------------------------------------------------
import linuxcnc
s = linuxcnc.stat()
c = linuxcnc.command() 

def ok_for_mdi():
    s.poll()
    return not s.estop and s.enabled and
        s.homed and (s.interp_state == linuxcnc.INTERP_IDLE)

if ok_for_mdi():
   c.mode(linuxcnc.MODE_MDI)   
   c.wait_complete() # wait until mode switch executed
   c.mdi("G0 X10 Y20 Z30")
---------------------------------------------------------------------

==  Sending commands through `linuxcnc.command`

Before sending a command, initialize a command channel like so:

[source,python]
---------------------------------------------------------------------
import linuxcnc
c = linuxcnc.command() 

# Usage examples for some of the commands listed below:
c.abort()

c.auto(linuxcnc.AUTO_RUN, program_start_line)
c.auto(linuxcnc.AUTO_STEP)
c.auto(linuxcnc.AUTO_PAUSE)
c.auto(linuxcnc.AUTO_RESUME)

c.brake(linuxcnc.BRAKE_ENGAGE)
c.brake(linuxcnc.BRAKE_RELEASE)

c.flood(linuxcnc.FLOOD_ON)
c.flood(linuxcnc.FLOOD_OFF)

c.home(2)

c.jog(linuxcnc.JOG_STOP, axis) 
c.jog(linuxcnc.JOG_CONTINUOUS, axis, speed) 
c.jog(linuxcnc.JOG_INCREMENT, axis, speed, increment)

c.load_tool_table()

c.maxvel(200.0)

c.mdi("G0 X10 Y20 Z30")

c.mist(linuxcnc.MIST_ON)
c.mist(linuxcnc.MIST_OFF)

c.mode(linuxcnc.MODE_MDI)   
c.mode(linuxcnc.MODE_AUTO)   
c.mode(linuxcnc.MODE_MANUAL)   

c.override_limits()

c.program_open("foo.ngc")
c.reset_interpreter()

c.set_home_parameters(jointnum, home_pos, home_offset, home_final_velocity, home_search_velocity, home_final_velocity, use_index, ignore_limits, is_shared, home_sequence, volatile_home, locking_indexer) )


c.tool_offset(toolno, z_offset,  x_offset, diameter, frontangle, backangle, orientation)
---------------------------------------------------------------------
=== `linuxcnc.command` attributes

`serial`::
	the current command serial number

=== `linuxcnc.command` methods:

`abort()`::
	send EMC_TASK_ABORT message.

`auto(int[, int])`:: 
	run, step, pause or resume a program.

`brake(int)`::
	engage or release spindle brake.
        
`debug(int)`::
	set debug level via EMC_SET_DEBUG message.

`feedrate(float)`::
	set the feedrate.

`flood(int)`::
	turn on/off flooding.

`home(int)`::
	home a given axis.

`jog(int, int, [, int[,int]])`::
	Syntax: +
	jog(command, axis[, velocity[, distance]]) +
	jog(linuxcnc.JOG_STOP, axis) +
	jog(linuxcnc.JOG_CONTINUOUS, axis, velocity) +
	jog(linuxcnc.JOG_INCREMENT, axis, velocity, distance) +
	Constants: +
	JOG_STOP (0) +
	JOG_CONTINUOUS (1) +
	JOG_INCREMENT (2)

`load_tool_table()`::
	reload the tool table.

`maxvel(float)`::
	set maximum velocity

`mdi(string)`::
	send an MDI command. Maximum 255 chars.

`mist(int)`:: turn on/off mist. +
	Syntax: +
	mist(command) +
	mist(linuxcnc.MIST_ON) [(1)] +
	mist(linuxcnc.MIST_OFF) [(0)] +
	Constants: +
	MIST_ON (1) +
	MIST_OFF (0)


`mode(int)`::
	set mode (MODE_MDI, MODE_MANUAL, MODE_AUTO).

`override_limits()`::
	set the override axis limits flag.

`program_open(string)`::
	open an NGC file.

`reset_interpreter()`::
	reset the RS274NGC interpreter

`set_adaptive_feed(int)`::
	set adaptive feed flag

`set_analog_output(int, float)`::
	set analog output pin to value

`set_block_delete(int)`::
	set block delete flag

`set_digital_output(int, int)`::
	set digital output pin to value

`set_feed_hold(int)`::
	set feed hold on/off

`set_feed_override(int)`::
	set feed override on/off

`set_max_limit(int, float)`::
        set max position limit for a given axis
        
'set_home_parameters(int, float, float, float, float, float, int, int, int, int, int, int::
	set home parameters for a given axis. All parameters must be passed to the function to succeed.

`set_min_limit()`::
        set min position limit for a given axis

`set_optional_stop(int)`::
	set optional stop on/off

`set_spindle_override(int)`::
	set spindle override flag

`spindle(int)`::
	set spindle direction. Argument one of SPINDLE_FORWARD,
	SPINDLE_REVERSE, SPINDLE_OFF, SPINDLE_INCREASE,
	SPINDLE_DECREASE, or SPINDLE_CONSTANT.

`spindleoverride(float)`::
	set spindle override factor

`state(int)`::
	set the machine state. Machine state should be STATE_ESTOP, STATE_ESTOP_RESET, STATE_ON, or STATE_OFF

`teleop_enable(int)`::
	enable/disable teleop mode.

`teleop_vector(float, float, float [,float, float, float])`::
        set teleop destination vector

`tool_offset(int, float, float, float, float, float, int)`::
        set the tool offset. See usage example above.

`traj_mode(int)`::
	set trajectory mode. Mode is one of MODE_FREE, MODE_COORD, or
	MODE_TELEOP.

`unhome(int)`::
	unhome a given axis.

`wait_complete([float])`::
	wait for completion of the last command sent. If timeout in
	seconds not specified, default is 1 second.


== Reading the error channel

To handle error messages, connect to the error channel and
periodically poll() it.

Note that the NML channel for error messages has a queue (other than
the command and status channels), which means
that the first consumer of an error message deletes that message from
the queue; whether your another error message consumer (e.g. Axis)
will 'see' the message is dependent on timing. It is recommended to have just
one error channel reader task in a setup.


[source,python]
---------------------------------------------------------------------
import linuxcnc
e = linuxcnc.error_channel()

error = e.poll()

if error: 
    kind, text = error
    if kind in (linuxcnc.NML_ERROR, linuxcnc.OPERATOR_ERROR):
        typus = "error"
    else:
        typus = "info"
        print typus, text
---------------------------------------------------------------------


== Reading ini file values [[sec:Python-reading-ini-values]]

Here's an example for reading values from an ini file through the
`linuxcnc.ini` object:

[source,python]
---------------------------------------------------------------------
# run as:
# python ini-example.py ~/emc2-dev/configs/sim/axis/axis_mm.ini

import sys
import linuxcnc

inifile = linuxcnc.ini(sys.argv[1])

# inifile.find() returns None if the key wasnt found - the
# following idiom is useful for setting a default value:

machine_name = inifile.find('EMC', 'MACHINE') or "unknown"
print "machine name: ", machine_name

# inifile.findall() returns a list of matches, or an empty list
# if the key wasnt found:

extensions = inifile.findall("FILTER", "PROGRAM_EXTENSION")
print "extensions: ", extensions

# override default NML file by ini parameter if given
nmlfile = inifile.find("EMC", "NML_FILE")
if nmlfile:
    linuxcnc.nmlfile = os.path.join(os.path.dirname(sys.argv[1]), nmlfile)
---------------------------------------------------------------------

== The `linuxcnc.positionlogger` type

Some usage hints can be gleaned from
`src/emc/usr_intf/gremlin/gremlin.py`.


=== members

`npts`::
	number of points.

=== methods
`start(float)`::
	start the position logger and run every ARG seconds

`clear()`::
	clear the position logger

`stop()`::
	stop the position logger

`call()`::
	Plot the backplot now.

`last([int])`::
	Return the most recent point on the plot or None
,
